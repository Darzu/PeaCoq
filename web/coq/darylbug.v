(* Homework 01 *)

(* include some library code *)
Require Import List.
Require Import NPeano.

(* decide if two nats are equal *)
Fixpoint nat_eq (m n: nat) : bool :=
  match m, n with
    | O, O => true
    | S mp, S np => nat_eq mp np
    | _, _ => false
  end.

(* [PROBLEM 1]

Define nat_le to decide if one nat is less than or equal to another.

Hint: You do not need to use any form of disjunction.
*)
Fixpoint nat_le (m n: nat) : bool :=
  match m, n with
    | O, _ => true
    | S mp, O => false
    | S mp, S np => nat_le mp np
  end.

Eval cbv in (nat_le 5 5). (* true *)
Eval cbv in (nat_le 3 5). (* true *)
Eval cbv in (nat_le 5 3). (* false *)

(* [PROBLEM 2]

Uset nat_le to define nat_lt which should decide if one nat is less than another.

For full credit, do not use other boolean functions.
*)
Definition nat_lt (m n: nat) : bool :=
  match m, n with
    | _, O => false
    | O, _ => true
    | S _, S np => nat_le m np
  end.

Eval cbv in (nat_lt 5 5). (* false *)
Eval cbv in (nat_lt 3 5). (* true *)
Eval cbv in (nat_lt 5 3). (* false *)

(* binary trees of nats *)
Inductive nat_tree : Set :=
| Leaf : nat_tree
| Branch : nat -> nat_tree -> nat_tree -> nat_tree.

(* ordered insertion *)
Fixpoint insert (n: nat) (nt: nat_tree) : nat_tree :=
  match nt with
    | Leaf => Branch n Leaf Leaf
    | Branch m tl tr =>
        if nat_lt n m then
          Branch m (insert n tl) tr
        else
          Branch m tl (insert n tr)
  end.

Eval cbv in (insert 3 Leaf).
Eval cbv in (insert 5 (insert 7 (insert 3 Leaf))).

(* [PROBLEM 3]

Define of_list to produce an ordered tree containing all elements from the list.

Use insert to help with sorting. Do not worry about duplicates in the list.
*)
Fixpoint of_list (ns: list nat) : nat_tree :=
  match ns with
    | nil => Leaf
    | x::xs => (insert x (of_list xs))
  end.

Eval cbv in (of_list (5::7::3::nil)).
Eval cbv in (of_list (3::7::5::nil)).
Eval cbv in (of_list (nil)).
Eval cbv in (of_list (1::1::nil)).

(* [PROBLEM 4]

Define to_list, which provides a list of elements generated by an in-order traversal of the tree nt.

For the difference between in-order, post-order, and pre-order traversals, see:
    http://en.wikipedia.org/wiki/Tree_traversal

Recall from lecture that we can append with the ++ operator.
*)
Fixpoint to_list (nt: nat_tree) : list nat :=
  match nt with
    | Leaf => nil
    | Branch m tl tr => to_list tl ++ m::nil ++ to_list tr
  end.

(* Should be: 3::5::7::nil *) 
Eval cbv in (to_list (Branch 3 Leaf (Branch 7 (Branch 5 Leaf Leaf) Leaf))).
Eval cbv in (to_list (Branch 5 (Branch 3 Leaf Leaf) (Branch 7 Leaf Leaf))).
Eval cbv in (to_list (of_list (3::7::5::nil))).
Eval cbv in (to_list (of_list (7::3::5::nil))).
Eval cbv in (to_list (of_list (5::3::7::nil))). 

(* [PROBLEM 5]

Define sum to add up all the nats in a nat_tree.
*)
Fixpoint sum (nt: nat_tree) : nat :=
  match nt with
    | Leaf => 0
    | Branch m tl tr => m + (sum tl) + (sum tr)
  end.

Eval cbv in (sum (of_list (1::2::3::nil))).
Eval cbv in (sum (of_list (99::1::nil))).
Eval cbv in (sum (of_list (nil))).

(* [PROBLEM 6]

Define prod to multiply up all the nats in a nat_tree.
*)
Fixpoint prod (nt: nat_tree) : nat :=
  match nt with
    | Leaf => 1
    | Branch m tl tr => m * (prod tl) * (prod tr)
  end.

Eval cbv in (prod (of_list (1::2::3::nil))).
Eval cbv in (prod (of_list (9::1::nil))).
Eval cbv in (prod (of_list (9::0::nil))).
Eval cbv in (prod (of_list (nil))).

(* [PROBLEM 7]

Define size to produce the number of nats in a nat_tree.

Note that Leaf should have size 0.
*)
Fixpoint size (nt: nat_tree) : nat :=
  match nt with
    | Leaf => 0
    | Branch m tl tr => 1 + (size tl) + (size tr)
  end.

Eval cbv in (size (of_list (1::2::3::nil))).
Eval cbv in (size (of_list (9::1::nil))).
Eval cbv in (size (of_list (9::0::nil))).
Eval cbv in (size (of_list (nil))).

(* [PROBLEM 8]

Define avg to compute the arithmetic mean of all the nats in a nat_tree.

Notes: Infix / is nat division. The average of an empty tree will be 0.
*)
Definition avg (nt: nat_tree) : nat :=
  (sum nt) / (size nt).

Eval cbv in (avg (of_list (1::2::3::nil))).
Eval cbv in (avg (of_list (9::1::nil))).
Eval cbv in (avg (of_list (9::0::nil))).
Eval cbv in (avg (of_list (nil))).

(* [PROBLEM 9]

Define map to apply a function of type nat -> nat to every nat in a nat_tree.

The resulting tree should have exactly the same structure as the initial tree.
*)
Fixpoint map (f: nat -> nat) (nt: nat_tree) : nat_tree :=
  match nt with
    | Leaf => Leaf
    | Branch m tl tr => Branch (f m) (map f tl) (map f tr)
  end.

Eval cbv in (to_list (map (fun a => a + 1) (of_list (1::2::3::nil)))). (* 2::3::4::nil *)
Eval cbv in (to_list (map (fun a => a * a) (of_list (1::2::3::nil)))). (* 1::4::9::nil *)

(* [PROBLEM 10]

Define increment_all to add one to all the nats in a nat_tree.

For full credit, do not use recursion (keep the Definition, don't change to Fixpoint).
*)
Definition increment_all (nt: nat_tree) : nat_tree :=
  map (fun a => a + 1) nt.

Eval cbv in (to_list (increment_all (of_list (1::2::3::nil)))). (* 2::3::4::nil *)

(* fold over nat_trees *)
Fixpoint fold {T: Type} (base: T) (f: T -> nat -> T) (nt: nat_tree) : T :=
  match nt with
    | Leaf => base
    | Branch n l r => f (fold (fold base f l) f r) n
  end.

(* [PROBLEM 11]

Define sum' to add up all the nats in a nat_tree.

For full credit, do not use recursion (keep the Definition, don't change to Fixpoint).
*)
Definition sum' := fold 0 (fun a b => a + b).

Eval cbv in (sum' (of_list (1::2::3::nil))).
Eval cbv in (sum' (of_list (99::1::nil))).
Eval cbv in (sum' (of_list (nil))).

(* [PROBLEM 12]

Define prod' to multiply up all the nats in a nat_tree.

For full credit, do not use recursion (keep the Definition, don't change to Fixpoint).
*)
Definition prod' := fold 1 (fun a b => a * b).

Eval cbv in (prod' (of_list (1::2::3::nil))).
Eval cbv in (prod' (of_list (9::1::nil))).
Eval cbv in (prod' (of_list (9::0::nil))).
Eval cbv in (prod' (of_list (nil))).

(* [PROBLEM 13]

Define avg' to compute the arithmetic mean of all the nats in a nat_tree.

For full credit, use fold.

Hint: Use let and a pair.
*)

Eval cbv in (pair 1 2).

Definition avg' (nt: nat_tree) : nat :=
  (let (totalSum, totalSize) := 
      (fold 
        (pair 0 0)
        (fun sumAndSize n => 
          let (sum, size) := sumAndSize in (pair (sum + n) (size + 1)))
        nt)
    in (totalSum / totalSize)).

Eval cbv in (avg' (of_list (1::2::3::nil))).
Eval cbv in (avg' (of_list (9::1::nil))).
Eval cbv in (avg' (of_list (9::0::nil))).
Eval cbv in (avg' (of_list (nil))).

(* [PROBLEM 14]

Define mirror to flip all the branches in the tree:

       5              5
      / \            / \
     3   4     =>   4   3
    / \                / \
   1   6              6   1

(leaves are not displayed above)
*)
Fixpoint mirror (nt: nat_tree) : nat_tree :=
  match nt with
    | Leaf => Leaf
    | Branch m lt rt => Branch m (mirror rt) (mirror lt)
  end.

Eval cbv in (to_list (mirror (of_list (1::2::3::nil)))).

(* test if a nat appears in a given tree *)
Fixpoint mem (n: nat) (nt: nat_tree) : bool :=
  match nt with
    | Leaf => false
    | Branch m l r =>
      if nat_eq n m then
        true
      else if nat_lt n m then
        mem n l
      else
        mem n r
  end.

Eval cbv in (mem 2 (of_list (1::2::3::nil))).
Eval cbv in (mem 4 (of_list (1::2::3::nil))).

(* prove all the following lemmas *)

(* Warning!  This first one may be tricky... *)
Lemma nat_eq_ok:
  forall m n, nat_eq m n = true -> m = n.
Proof.
  intro. induction m.
  { intros. destruct n.
    { reflexivity. }
    { discriminate. }
  }
  { intro. induction n.
    { discriminate. }
    { firstorder. }
  }
Qed.

Lemma nat_le_ok:
  forall m n, nat_le m n = true -> m <= n.
Proof.
  intro. induction m.
  { firstorder. }
  { intro. induction n.
    { discriminate. }
    { firstorder. }
  }
Qed.

(* Hint: use nat_le_ok *)
Lemma nat_lt_ok:
  forall m n, nat_lt m n = true -> m < n.
Proof.
  intro. induction m.
  { intro. induction n.
    { discriminate. }
    { firstorder. }
  }
  { intro. induction n.
    { discriminate. }
    { intro. destruct m.
      { firstorder. }
      { firstorder. }
    }
  }
Qed.

(* Show that our nat equality decider is reflexive. *)
Lemma nat_eq_refl : forall n, nat_eq n n = true.
Proof.
  intro. induction n.
  { reflexivity. }
  { firstorder. }
Qed.

Theorem map_size : forall f t, size (map f t) = size t.
Proof.
  intros. induction t.
  { reflexivity. }
  { simpl. firstorder. }
Qed.

Theorem mirror_size : forall t, size (mirror t) = size t.
Proof.
  intro. induction t.
  { reflexivity. }
  { simpl. rewrite -> IHt1. rewrite -> IHt2. firstorder. }
Qed.

(*
We define the custom tactic break_if to help with some proofs below.

Don't worry about understanding the details for now.

Just remember that if you see an if-then-else, break_if will do case analysis on the branch condition and give you two subgoals: one where the branch condition was true and so the then branch was taken, and another where the branch condition was false and so the else branch was taken.
*)
Ltac break_if :=
  match goal with
    | |- context [ if ?cond then _ else _ ] => destruct cond as [] eqn:?
  end.

Lemma mem_left : forall v l r, mem v l = true -> mem v (Branch v l r) = true.
Proof.
  intros. simpl. rewrite -> nat_eq_refl. reflexivity.
Qed.

Lemma mem_right : forall v l r, mem v r = true -> mem v (Branch v l r) = true.
Proof.
  intros. simpl. rewrite -> nat_eq_refl. reflexivity.
Qed.

(* using the previous lemmas and tactics, prove that insertion implies membership *)
Theorem insert_mem :
  forall v t, mem v (insert v t) = true.
Proof.
  intros. induction t.
  { simpl. rewrite -> nat_eq_refl. reflexivity. }
  { simpl. break_if.
    { simpl. rewrite -> Heqb. break_if.
      { reflexivity. }
      { firstorder. }
    }
    { simpl. rewrite -> Heqb. break_if.
      { reflexivity. }
      { firstorder. }
    }
  }
Qed.


(* [PROBLEM 24]

Consider this alternate definition of fold:
*)
Fixpoint fold' {T: Type} (base: T) (f: T -> nat -> T) (nt: nat_tree) : T :=
  match nt with
    | Leaf => base
    | Branch n l r => fold' (f (fold' base f l) n) f r
  end.

Check fold.
Check fold'.
Print fold.

(*
For reference, the definition of fold:
fold = 
fix fold (T : Type) (base : T) (f : T -> nat -> T) (nt : nat_tree)
         {struct nt} : T :=
  match nt with
  | Leaf => base
  | Branch n l r => f (fold T (fold T base f l) f r) n
  end
     : forall T : Type, T -> (T -> nat -> T) -> nat_tree -> T

Argument T is implicit and maximally inserted
Argument scopes are [type_scope _ _ _]
*)

(*
In a short English paragraph, describe how fold and fold' differ.

Fold's recurse looks like:  Branch n l r => f (fold (fold base f l) f r) n
Fold''s recurse looks like: Branch n l r => fold' (f (fold' base f l) n) f r

Fold traverses in "post-order". Aka it first does fold down the left sub tree, then down the right sub tree, then the current node.
Fold' traverses "in-order". Aka it first does fold down the left sub tree, then on the current node, then down the right sub tree.

Optional Bonus (5 points):

What should be true about a particular f for the following to hold:

  forall b nt, fold b f nt = fold' b f nt

  So long as f doesn't care about the order in which it visits nodes, fold and fold'
  will behave the same. For example, if f is used to compute size, sum, or mem, 
  they'll behave identically. However, if for example f uses the traverse order
  to find the smallet number > 10, you may get different behavior. See the Eval
  examples below.

*)

(* sum works for both *)
Eval cbv in (fold 0 (fun b n => b + n) (of_list (1::2::3::nil))).
Eval cbv in (fold' 0 (fun b n => b + n) (of_list (1::2::3::nil))).

(* smallest num greater than 10 only works with this particular f with fold'
   because f uses knowledge of the traverse order. *)
Eval cbv in (fold' 0 (fun b n => if (andb (nat_le b 10) (nat_lt 10 n)) then n else b) (of_list (5::12::11::nil))). (* returns 11 *)

Eval cbv in (fold 0 (fun b n => if (andb (nat_le b 10) (nat_lt 10 n)) then n else b) (of_list (5::12::11::nil))). (* returns 12 *)
